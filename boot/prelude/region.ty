-'.1 ;+#*DeepFrozen '! 2 '!3 #&coerce'";+#!x <  0;+#(__return -'".+#(__return##run'!+#!x+#$null  ' 1 ;+#-SubrangeGuard '! 2 '!3 ##get'!<  0;+#(__return -'".+#(__return##run'!1# ;+#0SubrangeSubGuard '! 2 ' ' +#$null  ' /;+#'primInt+#*DeepFrozen +##Int1#MA min where null represents positive infinity;+##min '!+#*DeepFrozen2 '!3#MA min where null represents positive infinity##run'";+#!a ;+#!b  0;+#(__return -'"9.+#+__equalizer#(sameEver'"+#!a+#$null.+#(__return##run'!+#!b9.+#+__equalizer#(sameEver'"+#!b+#$null.+#(__return##run'!+#!a.+#(__return##run'!.+#!a##min'!+#!b+#$null  ' 1#MA max where null represents negative infinity;+##max '!+#*DeepFrozen2 '!3#MA max where null represents negative infinity##run'";+#!a ;+#!b  0;+#(__return -'"9.+#+__equalizer#(sameEver'"+#!a+#$null.+#(__return##run'!+#!b9.+#+__equalizer#(sameEver'"+#!b+#$null.+#(__return##run'!+#!a.+#(__return##run'!.+#!a##max'!+#!b+#$null  ' 1#QA get that returns null if index is out of bounds;+##get '!+#*DeepFrozen2 '!3#QA get that returns null if index is out of bounds##run'";+#$list ;+#%index  0;+#(__return -'"9-'"/>'!;+#%ok__1   9.+#*__comparer#(lessThan'"+#%index*& -'!.+#*__makeList##run'!+#$true9.+#*__comparer##geq'"+#%index.+#$list#$size' -'!.+#*__makeList##run'!+#$true.+#-__booleanFlow#+failureList'!*& +#%ok__1.+#(__return##run'!+#$null.+#(__return##run'!.+#$list##get'!+#%index+#$null  ' 1#Ó&Makes inequality-based regions for fully ordered positions like
 integers, float64s, and chars, where, for every position, there is a
 'next()' and 'previous()' operation.

 If you want similar regions over, for example, Strings or rational numbers,
 you'd have to do something else.

 The in edges are members of the region, as are the non-edges
 immediately following them. The out edges are not in the region, as
 are the non-edges immediately following them. Therefore, the empty
 region has args (true, []) while the full region has args
 (false, [])

 @param myBoundedLeft If true, then the even egdes are in-edges and the odd
                      edges are out-edges. Otherwise, vice verse.
 @param myEdges is an ascending list of one-dimensional fully ordered
                positions.
 @author Mark S. Miller;+#2OrderedRegionMaker '!+#*DeepFrozen2 '!3 ##run'$;+#&myType+#*DeepFrozen;+#&myName+##Str=+#/initBoundedLeft+#$Bool=+#)initEdges  0;+#(__return -'"-'*1#6Notational convenience;+#&region '!+#*DeepFrozen2 '!3#6Notational convenience##run'";+#+boundedLeft+#$Bool;+#%edges  0;+#(__return -'".+#(__return##run'!.+#2OrderedRegionMaker##run'$+#&myType+#&myName+#+boundedLeft+#%edges+#$null  ' 9-'"/>'!;+#%ok__2   9.+#*__comparer##geq'".+#)initEdges#$size' *&"9.+#*__comparer#'asBigAs'"..+#)initEdges##get'!*& #(previous' .+#)initEdges##get'!*& .+#*__makeList##run'!+#$true.+#-__booleanFlow#+failureList'!*& .+#-__booleanFlow#+failureList'!*& +#%ok__2-'"5+#)initEdges.+#)initEdges##run'"*&".+#)initEdges#$size' 5+#/initBoundedLeft.+#/initBoundedLeft##not'  5+#)initEdges.+#)initEdges#(snapshot' /;+#*myInParity+#'primInt 9+#/initBoundedLeft*& *&"/;+#%myLen+#'primInt .+#)initEdges#$size' /;+#'myTypeR.+#$Same##get'!+#&myType +#&myType/;+#-myBoundedLeft+#$Bool +#/initBoundedLeft/;+#'myEdges+#*DeepFrozen +#)initEdges1#WAs guards, regions only accept positions in the region.;+#$self '$ +#*DeepFrozen.+#-SubrangeGuard##get'!+#&myType.+#-SubrangeGuard##get'!+#*DeepFrozen2 '93#XReturns a ConstList of edge positions in ascending order#(getEdges'  0;+#(__return -'".+#(__return##run'!+#'myEdges+#$null  3#Pmostly prints in Monte sugared expression syntax#(_printOn'!;+##out  0;+#(__return -'"-'#1 ;+#)printEdge '! 2 '!3 ##run'";+#+boundedLeft ;+#$edge+#&myType 0;+#(__return -'"-'%.+##out#%print'!*#!(.+##out#%print'!+#&myName.+##out#%print'!9+#+boundedLeft*#$ >= *## < .+##out#%print'!..+#3simple__quasiParser#*valueMaker'!.+#*__makeList##run'!.+#3simple__quasiParser#)valueHole'!*& #*substitute'!.+#*__makeList##run'!+#$edge.+##out#%print'!*#!)+#$null  ' 1 ;+#-printInterval '! 2 '!3 ##run'";+#$left+#&myType;+#%right+#&myType 0;+#(__return -'"-'#.+##out#%print'!..+#3simple__quasiParser#*valueMaker'!.+#*__makeList##run'!.+#3simple__quasiParser#)valueHole'!*& #*substitute'!.+#*__makeList##run'!+#$left.+##out#%print'!*##..!.+##out#%print'!..+#3simple__quasiParser#*valueMaker'!.+#*__makeList##run'!.+#3simple__quasiParser#)valueHole'!*& #*substitute'!.+#*__makeList##run'!+#%right+#$null  ' 9.+#+__equalizer#(sameEver'"+#%myLen*& 9+#-myBoundedLeft-'#.+##out#%print'!*#'<empty .+##out#%print'!+#&myName.+##out#%print'!*#( region>-'#.+##out#%print'!*#&<full .+##out#%print'!+#&myName.+##out#%print'!*#( region>9.+#+__equalizer#(sameEver'"+#%myLen*&".+#)printEdge##run'"+#-myBoundedLeft.+#'myEdges##get'!*& -'#/=+#!i  9+#-myBoundedLeft-'".+#-printInterval##run'".+#'myEdges##get'!*& .+#'myEdges##get'!*&"*&$-'".+#)printEdge##run'"+#%false.+#'myEdges##get'!*& *&"0;+#'__break .+#&__loop##run'".+#+__iterWhile##run'!1 < '! 2 '!3 ##run'  .+#*__comparer#(lessThan'".+#!i##add'!*&"+#%myLen' 1#/While loop body< '! 2 '!3 ##run'"< < +#$Bool-'"0;+#*__continue -'#.+##out#%print'!*## | .+#-printInterval##run'".+#'myEdges##get'!+#!i.+#'myEdges##get'!.+#!i##add'!*&"5+#!i.+#!i##add'!*&$  +#$true'   9.+#*__comparer#(lessThan'"+#!i+#%myLen-'".+##out#%print'!*## | .+#)printEdge##run'"+#$true.+#'myEdges##get'!+#!i +#$null  3#¦!Is pos in the region?

 If it's in the type but not in the region, the answer is false.
 If it's not in the type, a problem is thrown.##run'!;+##pos+#&myType+#$Bool0;+#(__return -'"-'"0;+#'__break -'#/=+#,validFlag__3  +#$true6.+#&__loop##run'"+#'myEdges1#-For-loop body< '! 2 '!3 ##run'";+#&key__4 ;+#(value__5  -'".+#-__validateFor##run'!+#,validFlag__30;+#*__continue -'$/;+#!i  +#&key__4/;+#$edge  +#(value__59.+#*__comparer#+greaterThan'"+#$edge+##pos.+#(__return##run'!..+#+__equalizer#(sameEver'".+#!i##mod'!*&$+#*myInParity##not'  +#$null  ' 5+#,validFlag__3+#%false+#$null  .+#(__return##run'!..+#+__equalizer#(sameEver'".+#%myLen##mod'!*&$+#*myInParity##not' +#$null  3#0Alias for run/1.#(contains'!;+##pos+#&myType+#$Bool0;+#(__return -'".+#(__return##run'!.+#$self##run'!+##pos+#$null  3#†All Regions are also Guards, either coercing a
 specimen to a position in the region, or rejecting it.#&coerce'"=+#(specimen ;+#*optEjector +#'myTypeR0;+#(__return -'"-'"5+#(specimen.+#&myType#&coerce'"+#(specimen+#*optEjector9.+#$self##run'!+#(specimen.+#(__return##run'!+#(specimen.+#%throw#%eject'"+#*optEjector..+#3simple__quasiParser#*valueMaker'!.+#*__makeList##run'#.+#3simple__quasiParser#)valueHole'!*& *#6 is not in the region .+#3simple__quasiParser#)valueHole'!*&"#*substitute'!.+#*__makeList##run'".+#!M#'toQuote'!+#(specimen.+#!M#'toQuote'!+#$self+#$null  3#hReturn the type's trivial value if it is in the region,
 otherwise fail.#2getTheTrivialValue'  0;+#(__return -'".+#(__return##run'!.+#$self#&coerce'"/;+#!t  .+#&myType#2getTheTrivialValue' 1 ;+#.cantTrivialize '! 2 '!3 ##run'!<  0;+#(__return -'".+#%throw##run'!..+#3simple__quasiParser#*valueMaker'!.+#*__makeList##run'$*#.trivial value .+#3simple__quasiParser#)valueHole'!*& *#< is not available in region .+#3simple__quasiParser#)valueHole'!*&"#*substitute'!.+#*__makeList##run'"+#!t+#$self+#$null  ' +#$null  3#hNote that the empty region is bounded left, but it doesn't
 have a start#-isBoundedLeft' +#$Bool0;+#(__return -'".+#(__return##run'!+#-myBoundedLeft+#$null  3#À!Note that the empty region is bounded left, but it doesn't
 have a start.

 Returns the start or null. The start is the least element
 which is *in* the region.#+getOptStart' .+#&NullOk##get'!+#&myType0;+#(__return -'"9-'"/>'!;+#%ok__6   9+#-myBoundedLeft9.+#*__comparer##geq'"+#%myLen*&".+#*__makeList##run'!+#$true.+#-__booleanFlow#+failureList'!*& .+#-__booleanFlow#+failureList'!*& +#%ok__6.+#(__return##run'!.+#'myEdges##get'!*& .+#(__return##run'!+#$null+#$null  3#iNote that the empty region is bounded right, but it doesn't
 have a bound#.isBoundedRight' +#$Bool0;+#(__return -'".+#(__return##run'!.+#+__equalizer#(sameEver'".+#%myLen##mod'!*&$+#*myInParity+#$null  3#	!Note that the empty region is bounded right, but it doesn't
 have a bound.

 Returns the bound or null. The right bound is the least
 element greater than all elements in the region. Unlike the
 left bound, it is *not* in the region.#+getOptBound' .+#&NullOk##get'!+#&myType0;+#(__return -'"9-'"/>'!;+#%ok__7   9.+#*__comparer##geq'"+#%myLen*&"9.+#+__equalizer#(sameEver'".+#%myLen##mod'!*&$+#*myInParity.+#*__makeList##run'!+#$true.+#-__booleanFlow#+failureList'!*& .+#-__booleanFlow#+failureList'!*& +#%ok__7.+#(__return##run'!.+#'myEdges##get'!.+#%myLen#(subtract'!*&".+#(__return##run'!+#$null+#$null  3#â!Does this region contain no positions?

 An empty region can always be constructed by the intersection
 of a distinction and its complement, and is therefore an
 interval, but not a distinction.#'isEmpty' +#$Bool0;+#(__return -'".+#(__return##run'!-'"/>'!;+#%ok__8   9.+#+__equalizer#(sameEver'"+#%myLen*& 9+#-myBoundedLeft.+#*__makeList##run'!+#$true.+#-__booleanFlow#+failureList'!*& .+#-__booleanFlow#+failureList'!*& +#%ok__8+#$null  3#¶!Does this region contain all positions?

 The full region is the intersection (and) of no regions, and
 is therefore a interval but not a distinction.#&isFull' +#$Bool0;+#(__return -'".+#(__return##run'!-'"/>'!;+#%ok__9   9.+#+__equalizer#(sameEver'"+#%myLen*& 9.+#-myBoundedLeft##not' .+#*__makeList##run'!+#$true.+#-__booleanFlow#+failureList'!*& .+#-__booleanFlow#+failureList'!*& +#%ok__9+#$null  3#æ!All regions of a coordinate space can be made by and/or/nots
 of distinctions.

 The not of a distinction must be a distinction. For this space,
 the distinctions are (myType < y) and (myType >= y).#-isDistinction' +#$Bool0;+#(__return -'".+#(__return##run'!.+#+__equalizer#(sameEver'"+#%myLen*&"+#$null  3#ê#The intersection of distinctions must be an interval (it may
 or may not also be a distinction).

 Therefore, the
 intersection of intervals is also an interval. The
 intersection of no regions is the full region, which is a
 interval. The intersection of a distinction and its
 complement is the empty region, which is an interval. All
 distinctions are intervals. The complement of an interval
 need not be an interval. A non-interval is a complex
 region.#.isSimpleRegion' +#$Bool0;+#(__return -'"9.+#*__comparer##leq'"+#%myLen*&".+#(__return##run'!+#$true9.+#+__equalizer#(sameEver'"+#%myLen*&$.+#(__return##run'!+#-myBoundedLeft.+#(__return##run'!+#%false+#$null  3#¯#A region can be asked to decompose itself into intervals.

 The original region is the union (or) of these intervals.
 In the case of an OrderedRegion, the intervals returned are
 disjoint and ascending.

 If the region is full, this returns a singleton list
 containing the full interval. If this region is empty, then
 this return an empty list, since the empty region is the
 union of no regions.#0getSimpleRegions' +#$List0;+#(__return -'"-'%/;+#$flex  ..+#*__makeList##run' #'diverge' 9.+#-myBoundedLeft##not' 9.+#+__equalizer#(sameEver'"+#%myLen*& .+#$flex#$push'!.+#&region##run'"+#%false.+#*__makeList##run' .+#$flex#$push'!.+#&region##run'"+#%false.+#*__makeList##run'!.+#'myEdges##get'!*&  /=+#!i  +#*myInParity0;+#'__break .+#&__loop##run'".+#+__iterWhile##run'!1 < '! 2 '!3 ##run'  .+#*__comparer#(lessThan'"+#!i+#%myLen' 1#/While loop body< '! 2 '!3 ##run'"< < +#$Bool-'"0;+#*__continue -'".+#$flex#$push'!.+#&region##run'"+#$true.+#'myEdges##run'"+#!i.+#%myLen##min'!.+#!i##add'!*&$5+#!i.+#!i##add'!*&$  +#$true'   .+#(__return##run'!.+#$flex#(snapshot' +#$null  3#¯"An interval can be asked to decompose itself into distinctions.

 The original interval is the intersection (and) of these
 distinctions.

 The full interval returns a list of no distinctions. The
 empty interval return the list [(myType < 0), (myType >= 0)],
 ie, 0..!0.#/getDistinctions' +#$List0;+#(__return -'"9.+#+__equalizer#(sameEver'"+#%myLen*&".+#(__return##run'!.+#*__makeList##run'!+#$self9-'"/>'!;+#&ok__10   9.+#+__equalizer#(sameEver'"+#%myLen*&$9+#-myBoundedLeft.+#*__makeList##run'!+#$true.+#-__booleanFlow#+failureList'!*& .+#-__booleanFlow#+failureList'!*& +#&ok__10.+#(__return##run'!.+#*__makeList##run'".+#&region##run'"+#$true.+#*__makeList##run'!.+#'myEdges##get'!*& .+#&region##run'"+#%false.+#*__makeList##run'!.+#'myEdges##get'!*&"9.+#+__equalizer#(sameEver'"+#%myLen*& 9+#-myBoundedLeft.+#*__makeList##run'".+#&region##run'"+#%false.+#*__makeList##run'!*& .+#&region##run'"+#$true.+#*__makeList##run'!*& .+#(__return##run'!.+#*__makeList##run' .+#%throw##run'!*#Jcan only get distinctions from an interval+#$null  3#²!the region you get if you displace all my positions by
 offset.

 Note that offset may not be of myType. For example,
 "(char > 'a') + 3" is fine.##add'!;+#&offset  0;+#(__return -'"-'#/;+#$flex  ..+#*__makeList##run' #'diverge' 0;+#'__break -'#/=+#-validFlag__11  +#$true6.+#&__loop##run'"+#'myEdges1#-For-loop body< '! 2 '!3 ##run'";+#'key__12 ;+#)value__13  -'".+#-__validateFor##run'!+#-validFlag__110;+#*__continue -'$/<  +#'key__12/;+#$edge  +#)value__13.+#$flex#$push'!.+#$edge##add'!+#&offset+#$null  ' 5+#-validFlag__11+#%false+#$null  .+#(__return##run'!.+#&region##run'"+#-myBoundedLeft+#$flex+#$null  3#^the region you get if you displace all my positions by -offset#(subtract'!;+#&offset  0;+#(__return -'".+#(__return##run'!.+#$self##add'!.+#&offset#&negate' +#$null  3#VA region whose membership is the opposite of this one.##not'  0;+#(__return -'".+#(__return##run'!.+#&region##run'".+#-myBoundedLeft##not' +#'myEdges+#$null  3#Donly those positions in both regions##and'!;+#%other  0;+#(__return -'"-'(/;+#*otherEdges  .+#%other#(getEdges' /;+#(otherLen  .+#*otherEdges#$size' /;+#$flex  ..+#*__makeList##run' #'diverge' /=+#!i  .+#*myInParity#&negate' /=+#!j  9.+#%other#-isBoundedLeft' *& .*&"#&negate' /=+#.newBoundedLeft  +#$true0;+#'__break .+#&__loop##run'".+#+__iterWhile##run'!1 < '! 2 '!3 ##run'  -'"/>'!;+#&ok__14   9.+#*__comparer#(lessThan'"+#!i+#%myLen9.+#*__comparer#(lessThan'"+#!j+#(otherLen.+#*__makeList##run'!+#$true.+#-__booleanFlow#+failureList'!*& .+#-__booleanFlow#+failureList'!*& +#&ok__14' 1#/While loop body< '! 2 '!3 ##run'"< < +#$Bool-'"0;+#*__continue -')/;+##in1  .+##get##run'"+#'myEdges+#!i/;+##in2  .+##get##run'"+#*otherEdges+#!j/;+#$out1  .+##get##run'"+#'myEdges.+#!i##add'!*&"/;+#$out2  .+##get##run'"+#*otherEdges.+#!j##add'!*&"/;+#%maxin  .+##max##run'"+##in1+##in2/;+#&minout  .+##min##run'"+#$out1+#$out2/;+#$bleh  -'"/>'!;+#&ok__15   9.+#+__equalizer#(sameEver'"+#%maxin+#$null-'!.+#*__makeList##run'!+#$true9.+#+__equalizer#(sameEver'"+#&minout+#$null-'!.+#*__makeList##run'!+#$true.+#-__booleanFlow#+failureList'!*& +#&ok__159-'"/>'!;+#&ok__16   9+#$bleh-'!.+#*__makeList##run'!+#$true9.+#*__comparer#(lessThan'"+#%maxin+#&minout-'!.+#*__makeList##run'!+#$true.+#-__booleanFlow#+failureList'!*& +#&ok__16-'"9.+#+__equalizer#(sameEver'"+#%maxin+#$null5+#.newBoundedLeft+#%false.+#$flex#$push'!+#%maxin9..+#+__equalizer#(sameEver'"+#&minout+#$null##not' .+#$flex#$push'!+#&minout  9.+#+__equalizer#(sameEver'"+#$out2+#$null5+#!i.+#!i##add'!*&$9-'"/>'!;+#&ok__17   9..+#+__equalizer#(sameEver'"+#$out1+#$null##not' 9.+#*__comparer#(lessThan'"+#$out1+#$out2.+#*__makeList##run'!+#$true.+#-__booleanFlow#+failureList'!*& .+#-__booleanFlow#+failureList'!*& +#&ok__175+#!i.+#!i##add'!*&$5+#!j.+#!j##add'!*&$  +#$true'   .+#(__return##run'!.+#&region##run'"+#.newBoundedLeft+#$flex+#$null  3#>all positions in either region#"or'!;+#%other  0;+#(__return -'".+#(__return##run'!...+#$self##not' ##and'!.+#%other##not' ##not' +#$null  3#Dall position in me but not in other.#&butNot'!;+#%other  0;+#(__return -'".+#(__return##run'!.+#$self##and'!.+#%other##not' +#$null  3#nenumerates positions in ascending order.

 This doesn't necessarily terminate.#-_makeIterator'  0;+#(__return -'"-')9.+#-myBoundedLeft##not' .+#%throw##run'!*#1No least position 9.+#+__equalizer#(sameEver'"+#%myLen*& .+#(__return##run'!..+#*__makeList##run' #-_makeIterator'  /=+#!i  *& /=+#%index  *& /=+##pos  .+#'myEdges##get'!*& /=+##lim  +#$null9.+#*__comparer#+greaterThan'"+#%myLen*&"5+##lim.+#'myEdges##get'!*&" /=+#*endReached  +#%false.+#(__return##run'!1# ;+#(iterator '! 2 '!3 #$next'!;+#$done  0;+#(__return -'"-'"9+#*endReached.+#%throw#%eject'"+#$done*#.iteration done 9.+#*__comparer#(lessThan'".+#%index##add'!*&"+#%myLen-'%/;+##val  .+#*__makeList##run'"+#!i+##pos5+#!i.+#!i##add'!*&"5+##pos.+##pos#$next' 9..+#*__comparer#(lessThan'"+##pos+##lim##not' -'"5+#%index.+#%index##add'!*&$9.+#*__comparer##geq'"+#%index+#%myLen5+#*endReached+#$true-'"5+##pos.+#'myEdges##get'!+#%index5+##lim.+#'myEdges##get'!.+#%index##add'!*&" .+#(__return##run'!+##val9.+#*__comparer#(lessThan'"+#%index+#%myLen-'%/;+##val  .+#*__makeList##run'"+#!i+##pos/;+#'nextPos  .+##pos#$next' 5+#!i.+#!i##add'!*&"9.+#*__comparer#'asBigAs'"+##pos+#'nextPos5+#*endReached+#$true5+##pos+#'nextPos.+#(__return##run'!+##val +#$null  ' +#$null  3#\returned object will enumerate positions in descending order#*descending'  0;+#(__return -'"-''9.+#+__equalizer#(sameEver'"+#%myLen*& .+#(__return##run'!..+#*__makeList##run' #-_makeIterator'  /=+#!i  *& /=+#%index  .+#%myLen#(subtract'!*&"/=+##pos  ..+#'myEdges##get'!+#%index#(previous' /=+##lim  .+#'myEdges##get'!.+#%index#(subtract'!*&"/=+#*endReached  +#%false.+#(__return##run'!1# ;+#)descender '! 2 '"3 #-_makeIterator'  0;+#(__return -'"-'"9..+#$self#.isBoundedRight' ##not' .+#%throw##run'!*#4No greatest position .+#(__return##run'!+#)descender+#$null  3 #$next'!;+#$done  0;+#(__return -'"-'"9+#*endReached.+#%throw#%eject'"+#$done*#.Iteration done 9.+#*__comparer##geq'"+#%index*&"-'%/;+##val  .+#*__makeList##run'"+#!i+##pos5+#!i.+#!i##add'!*&"5+##pos.+##pos#(previous' 9..+#*__comparer##geq'"+##pos+##lim##not' -'"5+#%index.+#%index#(subtract'!*&$9.+#*__comparer#(lessThan'"+#%index*& 5+#*endReached+#$true-'"5+##pos..+#'myEdges##get'!+#%index#(previous' 9.+#*__comparer#+greaterThan'"+#%index*& 5+##lim.+#'myEdges##get'!.+#%index#(subtract'!*&"  .+#(__return##run'!+##val9.+#+__equalizer#(sameEver'"+#%index*& -'%/;+##val  .+#*__makeList##run'"+#!i+##pos/;+#'prevPos  .+##pos#(previous' 5+#!i.+#!i##add'!*&"9..+#*__comparer#(lessThan'"+##pos+#'prevPos##not' 5+#*endReached+#$true5+##pos+#'prevPos.+#(__return##run'!+##val +#$null  ' +#$null  3#LAs a region, my comparison is a subset test.#'op__cmp'!;+#%other +#&Double0;+#(__return -'"-'#/;+#)selfExtra  ...+#$self##and'!.+#%other##not' #'isEmpty' ##not' /;+#*otherExtra  ...+#%other##and'!.+#$self##not' #'isEmpty' ##not' 9+#)selfExtra9+#*otherExtra.+#(__return##run'!+##NaN.+#(__return##run'!*$_      9+#*otherExtra.+#(__return##run'!.*$_      #&negate' .+#(__return##run'!*$        +#$null  ' .+#(__return##run'!+#$self+#$null  ' 1 ;+#1OrderedSpaceMaker '!+#*DeepFrozen2 '!3#Í!Given a type whose reflexive (x <=> x) instances are fully
 ordered, this makes an OrderedSpace for making Regions and
 Twisters for those instances using operator notation.##run'";+#&myType+#*DeepFrozen;+#&myName+##Str 0;+#(__return -'"-'#1#6Notational convenience;+#&region '!+#*DeepFrozen2 '!3#6Notational convenience##run'";+#+boundedLeft+#$Bool;+#%edges  0;+#(__return -'".+#(__return##run'!.+#2OrderedRegionMaker##run'$+#&myType+#&myName+#+boundedLeft+#%edges+#$null  ' /;+#,OrderedSpace  8-'"/@+#%super ,+#&myType1#¶!The OrderedSpace delegates to the myType.
 <p>
 Of all normal guard messages, the only one it implements itself
 rather than delegating is _printOn/1.;+#,OrderedSpace '!+#*DeepFrozen2 '$3#VJust uses the name used to construct this OrderedSpace#(_printOn'!;+##out  0;+#(__return -'".+##out#%print'!+#&myName+#$null  3#`One step in executing the expansion of the relational
 operators#'op__cmp'!;+##myY+#&myType 0;+#(__return -'".+#(__return##run'!1# ;+#+regionMaker '! 2 '%3#.(myType < myY)#)belowZero'  0;+#(__return -'".+#(__return##run'!.+#&region##run'"+#%false.+#*__makeList##run'!+##myY+#$null  3#/(myType <= myY)#*atMostZero'  0;+#(__return -'"-'"/;+#%nextY  .+##myY#$next' 9.+#*__comparer#'asBigAs'"+##myY+#%nextY.+#(__return##run'!.+#&region##run'"+#%false.+#*__makeList##run' .+#(__return##run'!.+#&region##run'"+#%false.+#*__makeList##run'!+#%nextY+#$null  3#0(myType <=> myY)#&isZero'  0;+#(__return -'"-'"/;+#%nextY  .+##myY#$next' 9.+#*__comparer#'asBigAs'"+##myY+#%nextY.+#(__return##run'!.+#&region##run'"+#$true.+#*__makeList##run'!+##myY.+#(__return##run'!.+#&region##run'"+#$true.+#*__makeList##run'"+##myY+#%nextY+#$null  3#/(myType >= myY)#+atLeastZero'  0;+#(__return -'".+#(__return##run'!.+#&region##run'"+#$true.+#*__makeList##run'!+##myY+#$null  3#.(myType > myY)#)aboveZero'  0;+#(__return -'"-'"/;+#%nextY  .+##myY#$next' 9.+#*__comparer#'asBigAs'"+##myY+#%nextY.+#(__return##run'!.+#&region##run'"+#$true.+#*__makeList##run' .+#(__return##run'!.+#&region##run'"+#$true.+#*__makeList##run'!+#%nextY+#$null  ' +#$null  3#—(myType + myOffset).
 <p>
 Note that myOffset doesn't have to be a member of myType. For
 example, "char + 3" is legal.##add'!;+#(myOffset  0;+#(__return -'"1 ;+#'twister '! 2 '%3 #(_printOn'!;+##out  0;+#(__return -'".+##out#%print'!..+#3simple__quasiParser#*valueMaker'!.+#*__makeList##run'%*#!(.+#3simple__quasiParser#)valueHole'!*& *## + .+#3simple__quasiParser#)valueHole'!*&"*#!)#*substitute'!.+#*__makeList##run'"+#&myName+#(myOffset+#$null  3 ##run'!;+#&addend+#&myType 0;+#(__return -'".+#(__return##run'!.+#&addend##add'!+#(myOffset+#$null  3 #)getOffset'  0;+#(__return -'".+#(__return##run'!+#(myOffset+#$null  3 ##add'!;+#*moreOffset  0;+#(__return -'".+#(__return##run'!.+#,OrderedSpace##add'!.+#(myOffset##add'!+#*moreOffset+#$null  3 #(subtract'!;+#*moreOffset  0;+#(__return -'".+#(__return##run'!.+#'twister##add'!.+#*moreOffset#&negate' +#$null  ' +#$null  3#1(myType - offset)#(subtract'!;+#&offset  0;+#(__return -'".+#(__return##run'!.+#,OrderedSpace##add'!.+#&offset#&negate' +#$null  '!4;+#(pair__18 .+#!M#,callWithPair'"+#%super+#(pair__18.+#(__return##run'!+#,OrderedSpace+#$null  ' 1 ;+#,testIterable '! 2 '!3 ##run'!;+#&assert  0;+#(__return -'"-'#/;+#(intspace  .+#1OrderedSpaceMaker##run'"+##Int*##Int/;+##reg  ..+#*__comparer##geq'"+#(intspace*& ##and'!.+#*__comparer#(lessThan'"+#(intspace*&*.+#&assert#%equal'"-'"/=+#-validFlag__19  +#$true6.+#0__accumulateList##run'"+##reg1#-For-loop body< '! 2 '!3 ##run'#;+#'key__20 ;+#)value__21 ;+#(skip__22  -'".+#-__validateFor##run'!+#-validFlag__19-'#/<  +#'key__20/;+#!x  +#)value__21+#!x' 5+#-validFlag__19+#%false.+#*__makeList##run'%*& *&"*&$*&&*&(+#$null  ' 1 ;+#/testContainment '! 2 '!3 ##run'!;+#&assert  0;+#(__return -'"-'%/;+#(intspace  .+#1OrderedSpaceMaker##run'"+##Int*##Int/;+##reg  ..+#*__comparer##geq'"+#(intspace*& ##and'!.+#*__comparer#(lessThan'"+#(intspace*&*.+#&assert#%equal'".+##reg##run'!*&&+#$true.+#&assert#%equal'".+##reg##run'!*&*+#%false.+#&assert#&throws'!1 < '! 2 '!3 ##run'  .+##reg##run'!*$_      ' +#$null  ' 1 ;+#)testGuard '! 2 '!3 ##run'!;+#&assert  0;+#(__return -'"-'$/;+#(intspace  .+#1OrderedSpaceMaker##run'"+##Int*##Int/;+##reg  ..+#*__comparer##geq'"+#(intspace*& ##and'!.+#*__comparer#(lessThan'"+#(intspace*&*.+#&assert#%equal'"/;+#!x+##reg *&&*&&.+#&assert#&ejects'!1 < '! 2 '!3 ##run'!;+#"ej  /;+#!x+##reg+#"ej*&.' +#$null  ' 1 ;+#.testDeepFrozen '! 2 '!3 ##run'!;+#&assert  0;+#(__return -'"-'%/;+#(intspace  .+#1OrderedSpaceMaker##run'"+##Int*##Int/;+##reg  ..+#*__comparer##geq'"+#(intspace*& ##and'!.+#*__comparer#(lessThan'"+#(intspace*&*/;+#!x+##reg *&$1 ;+#!y '" +#*DeepFrozen2 '!3 ##add'!;+#!a  0;+#(__return -'".+#(__return##run'!.+#!a##add'!+#!x+#$null  ' .+#&assert#%equal'"-'#/;+#&sp__23  +#!y/>'!;+#&ok__24   0;+#(fail__25 -'"/<+#*DeepFrozen+#(fail__25+#&sp__23.+#*__makeList##run'!+#$true;+#+problem__26 -'"/?+#/__slotToBinding@+#%b__27 .+##Ref#&broken'!+#+problem__26.+#*__makeList##run'!+#%false+#&ok__24+#$true+#$null  ' .+#(unittest##run'!.+#*__makeList##run'$+#,testIterable+#/testContainment+#)testGuard+#.testDeepFrozen.+#)__makeMap#)fromPairs'!.+#*__makeList##run'".+#*__makeList##run'"*#2OrderedRegionMaker+#2OrderedRegionMaker.+#*__makeList##run'"*#1OrderedSpaceMaker+#1OrderedSpaceMaker